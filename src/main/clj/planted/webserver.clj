(ns planted.webserver
  (:use [org.httpkit.server :only [run-server]])
  (:require [cemerick.friend :as friend]
            [clojure.tools.logging :as log]
            [com.stuartsierra.component :as component]
            [compojure.core :refer [routes wrap-routes ANY POST GET]]
            [compojure.route :as route]
            [liberator.core :refer [resource defresource get-options]]
            [liberator.dev :refer [wrap-trace]]
            [planted.api :refer [get-api-routes]]
            [ring.middleware.cookies :refer [wrap-cookies]]
            [ring.middleware.content-type :refer [wrap-content-type]]
            [ring.middleware.keyword-params :refer [wrap-keyword-params]]
            [ring.middleware.multipart-params :refer [wrap-multipart-params]]
            [ring.middleware.nested-params :refer [wrap-nested-params]]
            [ring.middleware.not-modified :refer [wrap-not-modified]]
            [ring.middleware.params :refer [wrap-params]]
            [ring.middleware.session :refer [wrap-session]]
            [ring.util.mime-type :as mime]
            [ring.util.response :refer [content-type redirect resource-response response status]]))

(defn log-request
  "Logs the request details, the start/end time and any exceptions"
  [handler]
  (fn [req]
    (log/info "Request start:" (:request-method req) (:uri req) (:query-string req))
    (log/trace "Request map:" (pr-str req))
    (try
      (let [res (handler req)]
        (log/info "Request end:" (:uri req) (:status res))
        res)
      (catch Throwable t
        (log/error t "Unhandled throwable")
        (throw t)))))

(defn- serve-resource [path]
  (let [response (resource-response path)]
    (if-let [mime-type (mime/ext-mime-type path)]
      (content-type response mime-type)
      response)))

(defn- serve-app-html []
  (serve-resource "public/planted.html"))

(def auth-routes
  [(GET "/user" request
     (let [userid (:current (friend/identity request))]
       (if userid
         (content-type (response userid) "text/plain")
         (status (redirect "/login") 403))))

   ;; The friend authentication will fall through to here on success
   ;; Return the name of the user that logged in
   (POST "/login" request
     (-> request
         friend/identity
         :current
         response
         (content-type "text/plain")))

   ;; Allow log-out (removes :cemerick.friend/identity from :session)
   (friend/logout (ANY "/logout" request (ring.util.response/redirect "/")))])

;; Static files are generated by the grunt build, serving them here is
;; just passing them through.
(def resource-routes
  [;; This call defaults to using "resources/public" folder as source
   (route/resources "/")

   ;; Planted is a single-page app. This means, whatever URL is actually
   ;; requested by the browser, we're always going to return the same
   ;; javascript app, which will internally detect the URL and render
   ;; appropriately.

   ;; These paths we know are good, so don't 404 them
   ;; TODO prerender the javascript app server side so we know for sure
   (GET "/" [] (serve-app-html))
   (GET ["/:_" :_ #"(plant|site).*"] [_] (serve-app-html))

   ;; Certain paths really should return 404 status, but still send along
   ;; the single page app; it can render the not-found message.
   (route/not-found (serve-app-html))])

(defn get-routes
  "Defines the Planted web server, which includes the REST web services and
  serving of static html/js files.
  The static assets should have been composed beforehand via grunt."
  [db]
  (apply routes (concat auth-routes
                        (get-api-routes db)
                        resource-routes)))

(defn wrap-web-server
  "Initializes the application web request handling and initializes some other
  ring request handlers to enhance it."
  [db auth-handler]
  (-> (get-routes db)

      ;; Log everything that comes in
      log-request

      ;; Debug logging for API
      (wrap-trace :header :ui)

      ;; Authentication
      auth-handler

      ;; Ring middleware libraries to plug in some handy functionality
      wrap-session
      wrap-cookies
      wrap-multipart-params
      wrap-params
      wrap-nested-params
      wrap-keyword-params
      wrap-not-modified
      wrap-content-type))

;; See docstring for new-webserver below
(defrecord WebServer [bind db auth shutdown-method]
  component/Lifecycle

  (start [this]
    (log/info "Starting Planted web server on" bind)
    (if (not db) (throw (Exception. "Web server component requires missing 'db' dependency.")))
    (if (not auth) (throw (Exception. "Web server component requires missing 'auth' dependency.")))
    (if shutdown-method
      this
      ;; The method returned from "run-server" shuts down the instance
      (let [routes (wrap-web-server db (:handler auth))
            shutdown-method (run-server routes {:port bind})]
        (assoc this :shutdown-method shutdown-method))))

  (stop [this]
    (log/info "Stopping Planted web server")
    (if (not shutdown-method)
      this
      (do (try (shutdown-method :timeout 250)
            (catch Throwable t
              (log/warn t "Error when shutting down web server")))
          (assoc this :shutdown-method nil)))))

(defn new-webserver
  "This class implements the Lifecycle interface providing start/stop methods
  for the web server part of this application (including web services and
  static files.) This implementation of Lifecycle is idempotent.

  The 'bind' parameter specifies what port the server shall bind to.

  The returned Lifecycle record requires a 'db' parameter to be bound."
  [bind]
  (map->WebServer {:bind bind}))